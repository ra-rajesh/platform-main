name: Terraform Apply

on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment
        required: true
        type: choice
        options: [dev, stage, prod]
        default: stage
      stack:
        description: Stack to deploy (all or a single stack)
        required: true
        type: choice
        options: [all, network, compute, ecr, s3, nlb, ssm, rest-api, cloudwatch]
        default: all

concurrency:
  group: tf-${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      AWS_REGION: ap-south-1
      TF_IN_AUTOMATION: "true"

      # Expose all env secrets so we can select by env (they stay secret in runner)
      AWS_ACCESS_KEY_ID_DEV:     ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
      AWS_SECRET_ACCESS_KEY_DEV: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
      AWS_ACCESS_KEY_ID_STAGE:   ${{ secrets.AWS_ACCESS_KEY_ID_STAGE }}
      AWS_SECRET_ACCESS_KEY_STAGE: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGE }}
      AWS_ACCESS_KEY_ID_PROD:    ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
      AWS_SECRET_ACCESS_KEY_PROD: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}

    steps:
      - uses: actions/checkout@v4

      # Pick the right keys based on "env" input
      - name: Select AWS access keys for env
        shell: bash
        run: |
          case "${{ inputs.env }}" in
            dev)
              echo "AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_ENV
              echo "AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_ENV
              ;;
            stage)
              echo "AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID_STAGE }}" >> $GITHUB_ENV
              echo "AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY_STAGE }}" >> $GITHUB_ENV
              ;;
            prod)
              echo "AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_ENV
              echo "AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Configure AWS credentials (access keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Apply stacks in order
        shell: bash
        run: |
          set -euo pipefail

          ENV="${{ inputs.env }}"
          SEL="${{ inputs.stack }}"

          ORDER=( network compute ecr s3 nlb ssm rest-api cloudwatch )
          if [[ "$SEL" != "all" ]]; then ORDER=("$SEL"); fi

          for S in "${ORDER[@]}"; do
            WD="infra/environments/${ENV}/stacks/${S}"
            if [[ ! -d "$WD" ]]; then
              echo "::warning::Skipping $WD (not found)"
              continue
            fi

            if [[ ! -f "${WD}/backend-${ENV}.hcl" ]]; then
              echo "::error::Missing ${WD}/backend-${ENV}.hcl"
              exit 1
            fi

            TFVARS_FLAG=""
            if [[ -f "${WD}/${ENV}.tfvars" ]]; then
              TFVARS_FLAG="-var-file=${ENV}.tfvars"
            else
              echo "::notice::No ${WD}/${ENV}.tfvars; relying on defaults/vars"
            fi

            echo "=== INIT: $WD"
            terraform -chdir="$WD" init -input=false -reconfigure -backend-config="backend-${ENV}.hcl"

            echo "=== PLAN: $WD"
            terraform -chdir="$WD" plan -input=false $TFVARS_FLAG -var="env_name=${ENV}" -out=tfplan

            echo "=== APPLY: $WD"
            terraform -chdir="$WD" apply -input=false -auto-approve tfplan

            echo "=== OUTPUTS: $WD"
            terraform -chdir="$WD" output || true
          done
