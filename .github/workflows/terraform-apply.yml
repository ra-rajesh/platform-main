name: Terraform Apply

on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment
        required: true
        type: choice
        options: [dev, stage, prod]
        default: stage
      stack:
        description: Stack to deploy (all or a single stack)
        required: true
        type: choice
        options: [all, network, compute, ecr, s3, nlb, ssm, rest-api, cloudwatch]
        default: all

concurrency:
  group: tf-${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      AWS_REGION: ap-south-1
      TF_IN_AUTOMATION: "true"
      AWS_ACCESS_KEY_ID_DEV:       ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
      AWS_SECRET_ACCESS_KEY_DEV:   ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
      AWS_ACCESS_KEY_ID_STAGE:     ${{ secrets.AWS_ACCESS_KEY_ID_STAGE }}
      AWS_SECRET_ACCESS_KEY_STAGE: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGE }}
      AWS_ACCESS_KEY_ID_PROD:      ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
      AWS_SECRET_ACCESS_KEY_PROD:  ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}

    steps:
      - uses: actions/checkout@v4

      - name: Select AWS access keys for env
        shell: bash
        run: |
          case "${{ inputs.env }}" in
            dev)
              echo "AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_ENV
              echo "AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_ENV
              ;;
            stage)
              echo "AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID_STAGE }}" >> $GITHUB_ENV
              echo "AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY_STAGE }}" >> $GITHUB_ENV
              ;;
            prod)
              echo "AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_ENV
              echo "AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Configure AWS credentials (access keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Apply stacks in order
        shell: bash
        run: |
          set -euo pipefail

          ENV="${{ inputs.env }}"
          SEL="${{ inputs.stack }}"
          ORDER=( network compute ecr s3 nlb ssm rest-api cloudwatch )
          if [[ "$SEL" != "all" ]]; then ORDER=("$SEL"); fi

          ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"
          TF_STATE_BUCKET="${ENV}-btl-idlms-backend-api-tfstate-${ACCOUNT_ID}"
          NETWORK_KEY="${ENV}/network/terraform.tfstate"
          COMPUTE_KEY="${ENV}/compute/terraform.tfstate"

          # Ensure the state bucket exists
          if ! aws s3api head-bucket --bucket "$TF_STATE_BUCKET" >/dev/null 2>&1; then
            echo "::error::State bucket $TF_STATE_BUCKET not found"
            exit 1
          fi

          for S in "${ORDER[@]}"; do
            WD="infra/environments/${ENV}/stacks/${S}"
            if [[ ! -d "$WD" ]]; then
              echo "::warning::Skipping $WD (not found)"
              continue
            fi
            if [[ ! -f "${WD}/backend-${ENV}.hcl" ]]; then
              echo "::error::Missing ${WD}/backend-${ENV}.hcl"
              exit 1
            fi

            TFVARS_FLAG=""
            if [[ -f "${WD}/${ENV}.tfvars" ]]; then
              TFVARS_FLAG="-var-file=${ENV}.tfvars"
            else
              echo "::notice::No ${WD}/${ENV}.tfvars; relying on inline vars/defaults"
            fi

            # Common explicit vars (so no prompts)
            EXTRA_VARS=( -var="env_name=${ENV}" -var="region=${{ env.AWS_REGION }}" )

            # Remote-state vars for stacks that read other stacks
            case "$S" in
              compute)
                EXTRA_VARS+=( -var="tf_state_bucket=${TF_STATE_BUCKET}"
                              -var="network_state_key=${NETWORK_KEY}" )
                # Provide safe defaults if no tfvars present
                if [[ -z "$TFVARS_FLAG" ]]; then
                  EXTRA_VARS+=( -var='ec2_name=Backend API IDLMS-stage'
                                -var='instance_type=t3.small'
                                -var='app_ports=[4000,4001,4002,4010]'
                                -var='ingress_cidrs=["0.0.0.0/0"]'
                                -var='ami_ssm_parameter_name=/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64' )
                fi
                ;;
              nlb)
                EXTRA_VARS+=( -var="tf_state_bucket=${TF_STATE_BUCKET}"
                              -var="network_state_key=${NETWORK_KEY}"
                              -var="compute_state_key=${COMPUTE_KEY}" )
                # Ensure compute state exists before planning NLB
                for _ in {1..12}; do
                  if aws s3 ls "s3://${TF_STATE_BUCKET}/${COMPUTE_KEY}" >/dev/null 2>&1; then
                    break
                  fi
                  echo "Waiting for compute state to appear..."
                  sleep 5
                done
                ;;
              rest-api|ssm|cloudwatch|ecr|s3)
                # Most of these do not need remote-state keys, leave as-is.
                :
                ;;
              network)
                :
                ;;
            esac

            echo "=== INIT: $WD"
            terraform -chdir="$WD" init -input=false -reconfigure -backend-config="backend-${ENV}.hcl"

            # ============================
            # ADOPT pre-existing resources
            # ============================
            echo "=== ADOPT (optional): $WD"
            if [[ "$S" == "compute" ]]; then
              PROFILE_NAME="${ENV}-ec2-ssm-instance-profile"
              ROLE_NAME="${ENV}-ec2-ssm-role"

              if aws iam get-instance-profile --instance-profile-name "$PROFILE_NAME" >/dev/null 2>&1; then
                if ! terraform -chdir="$WD" state list | grep -q 'module.compute.module.iam_ssm.aws_iam_instance_profile.this\[0\]'; then
                  terraform -chdir="$WD" import 'module.compute.module.iam_ssm.aws_iam_instance_profile.this[0]' "$PROFILE_NAME" || true
                fi
              fi
              if aws iam get-role --role-name "$ROLE_NAME" >/dev/null 2>&1; then
                if ! terraform -chdir="$WD" state list | grep -q 'module.compute.module.iam_ssm.aws_iam_role.this\[0\]'; then
                  terraform -chdir="$WD" import 'module.compute.module.iam_ssm.aws_iam_role.this[0]' "$ROLE_NAME" || true
                fi
              fi
            fi

            if [[ "$S" == "nlb" ]]; then
              NLB_NAME="${ENV}-idlms-nlb"
              LB_ARN="$(aws elbv2 describe-load-balancers --region "${{ env.AWS_REGION }}" --names "${NLB_NAME}" \
                        --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)"
              if [[ -n "$LB_ARN" && "$LB_ARN" != "None" ]]; then
                if ! terraform -chdir="$WD" state list | grep -q 'module.nlb.aws_lb.this'; then
                  terraform -chdir="$WD" import 'module.nlb.aws_lb.this' "$LB_ARN" || true
                fi
                # NOTE: listeners resource name is 'aws_lb_listener.this["<port>"]'
                while read -r PORT LARN; do
                  [[ -z "$PORT" || -z "$LARN" ]] && continue
                  ADDR="module.nlb.aws_lb_listener.this[\"$PORT\"]"
                  if ! terraform -chdir="$WD" state list | grep -q "$ADDR"; then
                    terraform -chdir="$WD" import "$ADDR" "$LARN" || true
                  fi
                done < <(aws elbv2 describe-listeners --region "${{ env.AWS_REGION }}" \
                              --load-balancer-arn "$LB_ARN" \
                              --query 'Listeners[].{P:Port,A:ListenerArn}' --output text 2>/dev/null | awk '{print $1, $2}')
              fi
              # TGs are named "<env>-idlms-nlb-<port>" and resource is aws_lb_target_group.multi["<port>"]
              TG_PREFIX="${NLB_NAME}-"
              while read -r TG_NAME TG_ARN; do
                [[ -z "$TG_NAME" || -z "$TG_ARN" ]] && continue
                if [[ "$TG_NAME" == ${TG_PREFIX}* ]]; then
                  PORT="${TG_NAME##*-}"
                  ADDR="module.nlb.aws_lb_target_group.multi[\"$PORT\"]"
                  if ! terraform -chdir="$WD" state list | grep -q "$ADDR"; then
                    terraform -chdir="$WD" import "$ADDR" "$TG_ARN" || true
                  fi
                fi
              done < <(aws elbv2 describe-target-groups --region "${{ env.AWS_REGION }}" \
                        --query 'TargetGroups[].{N:TargetGroupName,A:TargetGroupArn}' --output text 2>/dev/null | awk '{print $1, $2}')
            fi

            echo "=== PLAN: $WD"
            terraform -chdir="$WD" plan -input=false $TFVARS_FLAG "${EXTRA_VARS[@]}" -out=tfplan

            echo "=== APPLY: $WD"
            terraform -chdir="$WD" apply -input=false -auto-approve tfplan

            echo "=== OUTPUTS: $WD"
            terraform -chdir="$WD" output || true
          done
